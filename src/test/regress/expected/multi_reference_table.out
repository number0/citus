ALTER SEQUENCE pg_catalog.pg_dist_shardid_seq RESTART 1250000;
ALTER SEQUENCE pg_catalog.pg_dist_jobid_seq RESTART 1250000;
CREATE TABLE reference_table_test (value_1 int, value_2 float, value_3 text, value_4 timestamp);
-- user should not be able to create reference tables via master_create_distributed_table()
SELECT master_create_distributed_table('reference_table_test', 'value_1', 'all');
ERROR:  use create_reference_table() to create reference tables
-- user should not be able to create reference tables via create_distributed_table()
SELECT create_distributed_table('reference_table_test', 'value_1', 'all');
ERROR:  use create_reference_table() to create reference tables
-- insert some data, and make sure that cannot be create_distributed_table
INSERT INTO reference_table_test VALUES (1, 1.0, '1', '2016-12-05');
-- should error out given that there exists data
SELECT create_reference_table('reference_table_test');
ERROR:  cannot distribute relation "reference_table_test"
DETAIL:  Relation "reference_table_test" contains data.
HINT:  Empty your table before distributing it.
TRUNCATE reference_table_test;
-- now should be able to create the reference table
SELECT create_reference_table('reference_table_test');
 create_reference_table 
------------------------
 
(1 row)

-- see that partkey is NULL
SELECT
	partmethod, (partkey IS NULL) as partkeyisnull, colocationid
FROM
	pg_dist_partition
WHERE
	logicalrelid = 'reference_table_test'::regclass;
 partmethod | partkeyisnull | colocationid 
------------+---------------+--------------
 l          | t             |            3
(1 row)

-- now see that shard min/max values are NULL
SELECT
	shardid, (shardminvalue IS NULL) as shardminvalueisnull, (shardmaxvalue IS NULL) as shardmaxvalueisnull
FROM
	pg_dist_shard
WHERE
	logicalrelid = 'reference_table_test'::regclass;
 shardid | shardminvalueisnull | shardmaxvalueisnull 
---------+---------------------+---------------------
 1250000 | t                   | t
(1 row)

SELECT
	shardid, shardstate, nodename, nodeport
FROM
	pg_dist_shard_placement
WHERE
	shardid IN (SELECT shardid FROM pg_dist_shard WHERE logicalrelid = 'reference_table_test'::regclass);
 shardid | shardstate | nodename  | nodeport 
---------+------------+-----------+----------
 1250000 |          1 | localhost |    57637
 1250000 |          1 | localhost |    57638
(2 rows)

-- now, execute some modification queries
INSERT INTO reference_table_test VALUES (1, 1.0, '1', '2016-12-01');
INSERT INTO reference_table_test VALUES (2, 2.0, '2', '2016-12-02');
INSERT INTO reference_table_test VALUES (3, 3.0, '3', '2016-12-03');
INSERT INTO reference_table_test VALUES (4, 4.0, '4', '2016-12-04');
INSERT INTO reference_table_test VALUES (5, 5.0, '5', '2016-12-05');
-- most of the queries in this file are already tested on multi_router_planner.sql
-- However, for the sake of completeness we need to run similar tests with
-- reference tables as well
-- run some queries on top of the data
SELECT
	*
FROM
	reference_table_test;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
       2 |       2 | 2       | Fri Dec 02 00:00:00 2016
       3 |       3 | 3       | Sat Dec 03 00:00:00 2016
       4 |       4 | 4       | Sun Dec 04 00:00:00 2016
       5 |       5 | 5       | Mon Dec 05 00:00:00 2016
(5 rows)

SELECT
	*
FROM
	reference_table_test
WHERE
	value_1 = 1;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
(1 row)

SELECT
	value_1,
	value_2
FROM
	reference_table_test
ORDER BY
	2 ASC LIMIT 3;
 value_1 | value_2 
---------+---------
       1 |       1
       2 |       2
       3 |       3
(3 rows)

SELECT
	value_1, value_3
FROM
	reference_table_test
WHERE
	value_2 >= 4
ORDER BY
	2 LIMIT 3;
 value_1 | value_3 
---------+---------
       4 | 4
       5 | 5
(2 rows)

SELECT
	value_1, 15 * value_2
FROM
	reference_table_test
ORDER BY
	2 ASC
LIMIT 2;
 value_1 | ?column? 
---------+----------
       1 |       15
       2 |       30
(2 rows)

SELECT
	value_1, 15 * value_2
FROM
	reference_table_test
ORDER BY
	2 ASC LIMIT 2 OFFSET 2;
 value_1 | ?column? 
---------+----------
       3 |       45
       4 |       60
(2 rows)

SELECT
	value_2, value_4
FROM
	reference_table_test
WHERE
	value_2 = 2 OR value_2 = 3;
 value_2 |         value_4          
---------+--------------------------
       2 | Fri Dec 02 00:00:00 2016
       3 | Sat Dec 03 00:00:00 2016
(2 rows)

SELECT
	value_2, value_4
FROM
	reference_table_test
WHERE
	value_2 = 2 AND value_2 = 3;
 value_2 | value_4 
---------+---------
(0 rows)

SELECT
	value_2, value_4
FROM
	reference_table_test
WHERE
	value_3 = '2' OR value_1 = 3;
 value_2 |         value_4          
---------+--------------------------
       2 | Fri Dec 02 00:00:00 2016
       3 | Sat Dec 03 00:00:00 2016
(2 rows)

SELECT
	value_2, value_4
FROM
	reference_table_test
WHERE
	(
		value_3 = '2' OR value_1 = 3
	)
	AND FALSE;
 value_2 | value_4 
---------+---------
(0 rows)

SELECT
	*
FROM
	reference_table_test
WHERE
	value_2 IN
	(
		SELECT
			value_3::FLOAT
		FROM
			reference_table_test
	)
	AND value_1 < 3;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
       2 |       2 | 2       | Fri Dec 02 00:00:00 2016
(2 rows)

SELECT
	value_4
FROM
	reference_table_test
WHERE
	value_3 IN
	(
		'1', '2'
	);
         value_4          
--------------------------
 Thu Dec 01 00:00:00 2016
 Fri Dec 02 00:00:00 2016
(2 rows)

SELECT
	date_part('day', value_4)
FROM
	reference_table_test
WHERE
	value_3 IN
	(
		'5', '2'
	);
 date_part 
-----------
         2
         5
(2 rows)

SELECT
	value_4
FROM
	reference_table_test
WHERE
	value_2 <= 2 AND value_2 >= 4;
 value_4 
---------
(0 rows)

SELECT
	value_4
FROM
	reference_table_test
WHERE
	value_2 <= 20 AND value_2 >= 4;
         value_4          
--------------------------
 Sun Dec 04 00:00:00 2016
 Mon Dec 05 00:00:00 2016
(2 rows)

SELECT
	value_4
FROM
	reference_table_test
WHERE
	value_2 >= 5 AND value_2 <= random();
 value_4 
---------
(0 rows)

SELECT
	value_1
FROM
	reference_table_test
WHERE
	value_4 BETWEEN '2016-12-01' AND '2016-12-03';
 value_1 
---------
       1
       2
       3
(3 rows)

SELECT
	value_1
FROM
	reference_table_test
WHERE
	FALSE;
 value_1 
---------
(0 rows)

SELECT
	value_1
FROM
	reference_table_test
WHERE
	int4eq(1, 2);
 value_1 
---------
(0 rows)

-- rename output name and do some operations
SELECT
	value_1 as id, value_2 * 15 as age
FROM
	reference_table_test;
 id | age 
----+-----
  1 |  15
  2 |  30
  3 |  45
  4 |  60
  5 |  75
(5 rows)

-- queries with CTEs are supported
WITH some_data AS ( SELECT value_2, value_4 FROM reference_table_test WHERE value_2 >=3)
SELECT
	*
FROM
	some_data;
 value_2 |         value_4          
---------+--------------------------
       3 | Sat Dec 03 00:00:00 2016
       4 | Sun Dec 04 00:00:00 2016
       5 | Mon Dec 05 00:00:00 2016
(3 rows)

-- queries with CTEs are supported even if CTE is not referenced inside query
WITH some_data AS ( SELECT value_2, value_4 FROM reference_table_test WHERE value_2 >=3)
SELECT * FROM reference_table_test ORDER BY 1 LIMIT 1;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
(1 row)

-- queries which involve functions in FROM clause are supported if it goes to a single worker.
SELECT
	*
FROM
	reference_table_test, position('om' in 'Thomas')
WHERE
	value_1 = 1;
 value_1 | value_2 | value_3 |         value_4          | position 
---------+---------+---------+--------------------------+----------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016 |        3
(1 row)

SELECT
	*
FROM
	reference_table_test, position('om' in 'Thomas')
WHERE
	value_1 = 1 OR value_1 = 2;
 value_1 | value_2 | value_3 |         value_4          | position 
---------+---------+---------+--------------------------+----------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016 |        3
       2 |       2 | 2       | Fri Dec 02 00:00:00 2016 |        3
(2 rows)

-- set operations are supported
(SELECT * FROM reference_table_test WHERE value_1 = 1)
UNION
(SELECT * FROM reference_table_test WHERE value_1 = 3);
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
       3 |       3 | 3       | Sat Dec 03 00:00:00 2016
(2 rows)

(SELECT * FROM reference_table_test WHERE value_1 = 1)
EXCEPT
(SELECT * FROM reference_table_test WHERE value_1 = 3);
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
(1 row)

(SELECT * FROM reference_table_test WHERE value_1 = 1)
INTERSECT
(SELECT * FROM reference_table_test WHERE value_1 = 3);
 value_1 | value_2 | value_3 | value_4 
---------+---------+---------+---------
(0 rows)

-- to make the tests more interested for aggregation tests, ingest some more data
INSERT INTO reference_table_test VALUES (1, 1.0, '1', '2016-12-01');
INSERT INTO reference_table_test VALUES (2, 2.0, '2', '2016-12-02');
INSERT INTO reference_table_test VALUES (3, 3.0, '3', '2016-12-03');
-- some aggregations
SELECT
	value_4, SUM(value_2)
FROM
	reference_table_test
GROUP BY
	value_4
HAVING
	SUM(value_2) > 3
ORDER BY
	1;
         value_4          | sum 
--------------------------+-----
 Fri Dec 02 00:00:00 2016 |   4
 Sat Dec 03 00:00:00 2016 |   6
 Sun Dec 04 00:00:00 2016 |   4
 Mon Dec 05 00:00:00 2016 |   5
(4 rows)

SELECT
	value_4,
	value_3,
	SUM(value_2)
FROM
	reference_table_test
GROUP BY
	GROUPING sets ((value_4), (value_3))
ORDER BY 1, 2, 3;
         value_4          | value_3 | sum 
--------------------------+---------+-----
 Thu Dec 01 00:00:00 2016 |         |   2
 Fri Dec 02 00:00:00 2016 |         |   4
 Sat Dec 03 00:00:00 2016 |         |   6
 Sun Dec 04 00:00:00 2016 |         |   4
 Mon Dec 05 00:00:00 2016 |         |   5
                          | 1       |   2
                          | 2       |   4
                          | 3       |   6
                          | 4       |   4
                          | 5       |   5
(10 rows)

-- distinct clauses also work fine
SELECT DISTINCT
	value_4
FROM
	reference_table_test
ORDER BY
	1;
         value_4          
--------------------------
 Thu Dec 01 00:00:00 2016
 Fri Dec 02 00:00:00 2016
 Sat Dec 03 00:00:00 2016
 Sun Dec 04 00:00:00 2016
 Mon Dec 05 00:00:00 2016
(5 rows)

-- window functions are also supported
SELECT
	value_4, RANK() OVER (PARTITION BY value_1 ORDER BY value_4)
FROM
	reference_table_test;
         value_4          | rank 
--------------------------+------
 Thu Dec 01 00:00:00 2016 |    1
 Thu Dec 01 00:00:00 2016 |    1
 Fri Dec 02 00:00:00 2016 |    1
 Fri Dec 02 00:00:00 2016 |    1
 Sat Dec 03 00:00:00 2016 |    1
 Sat Dec 03 00:00:00 2016 |    1
 Sun Dec 04 00:00:00 2016 |    1
 Mon Dec 05 00:00:00 2016 |    1
(8 rows)

-- window functions are also supported
SELECT
	value_4, AVG(value_1) OVER (PARTITION BY value_4 ORDER BY value_4)
FROM
	reference_table_test;
         value_4          |          avg           
--------------------------+------------------------
 Thu Dec 01 00:00:00 2016 | 1.00000000000000000000
 Thu Dec 01 00:00:00 2016 | 1.00000000000000000000
 Fri Dec 02 00:00:00 2016 |     2.0000000000000000
 Fri Dec 02 00:00:00 2016 |     2.0000000000000000
 Sat Dec 03 00:00:00 2016 |     3.0000000000000000
 Sat Dec 03 00:00:00 2016 |     3.0000000000000000
 Sun Dec 04 00:00:00 2016 |     4.0000000000000000
 Mon Dec 05 00:00:00 2016 |     5.0000000000000000
(8 rows)

SELECT
	count(DISTINCT CASE
			WHEN
				value_2 >= 3
			THEN
				value_2
			ELSE
				NULL
			END) as c
	FROM
		reference_table_test;
 c 
---
 3
(1 row)

SELECT
	value_1,
	count(DISTINCT CASE
			WHEN
				value_2 >= 3
			THEN
				value_2
			ELSE
				NULL
			END) as c
	FROM
		reference_table_test
	GROUP BY
		value_1
	ORDER BY
		1;
 value_1 | c 
---------+---
       1 | 0
       2 | 0
       3 | 1
       4 | 1
       5 | 1
(5 rows)

-- selects inside a transaction works fine as well
BEGIN;
SELECT * FROM reference_table_test;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
       2 |       2 | 2       | Fri Dec 02 00:00:00 2016
       3 |       3 | 3       | Sat Dec 03 00:00:00 2016
       4 |       4 | 4       | Sun Dec 04 00:00:00 2016
       5 |       5 | 5       | Mon Dec 05 00:00:00 2016
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
       2 |       2 | 2       | Fri Dec 02 00:00:00 2016
       3 |       3 | 3       | Sat Dec 03 00:00:00 2016
(8 rows)

SELECT * FROM reference_table_test WHERE value_1 = 1;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
(2 rows)

END;
-- cursor queries also works fine
BEGIN;
DECLARE test_cursor CURSOR FOR
	SELECT *
		FROM reference_table_test
		WHERE value_1 = 1 OR value_1 = 2
		ORDER BY value_1;
FETCH test_cursor;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
(1 row)

FETCH ALL test_cursor;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 1       | Thu Dec 01 00:00:00 2016
       2 |       2 | 2       | Fri Dec 02 00:00:00 2016
       2 |       2 | 2       | Fri Dec 02 00:00:00 2016
(3 rows)

FETCH test_cursor; -- fetch one row after the last
 value_1 | value_2 | value_3 | value_4 
---------+---------+---------+---------
(0 rows)

END;
-- table creation queries inside can be router plannable
CREATE TEMP TABLE temp_reference_test as
	SELECT *
	FROM reference_table_test
	WHERE value_1 = 1;
-- all kinds of joins are supported among reference tables
-- first create two more tables
CREATE TABLE reference_table_test_second (value_1 int, value_2 float, value_3 text, value_4 timestamp);
SELECT create_reference_table('reference_table_test_second');
 create_reference_table 
------------------------
 
(1 row)

CREATE TABLE reference_table_test_third (value_1 int, value_2 float, value_3 text, value_4 timestamp);
SELECT create_reference_table('reference_table_test_third');
 create_reference_table 
------------------------
 
(1 row)

-- ingest some data to both tables
INSERT INTO reference_table_test_second VALUES (1, 1.0, '1', '2016-12-01');
INSERT INTO reference_table_test_second VALUES (2, 2.0, '2', '2016-12-02');
INSERT INTO reference_table_test_second VALUES (3, 3.0, '3', '2016-12-03');
INSERT INTO reference_table_test_third VALUES (4, 4.0, '4', '2016-12-04');
INSERT INTO reference_table_test_third VALUES (5, 5.0, '5', '2016-12-05');
-- some very basic tests
SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1, reference_table_test_second t2
WHERE
	t1.value_2 = t2.value_2
ORDER BY
	1;
 value_1 
---------
       1
       2
       3
(3 rows)

SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1, reference_table_test_third t3
WHERE
	t1.value_2 = t3.value_2
ORDER BY
	1;
 value_1 
---------
       4
       5
(2 rows)

SELECT
	DISTINCT t2.value_1
FROM
	reference_table_test_second t2, reference_table_test_third t3
WHERE
	t2.value_2 = t3.value_2
ORDER BY
	1;
 value_1 
---------
(0 rows)

-- join on different columns and different data types via casts
SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1, reference_table_test_second t2
WHERE
	t1.value_2 = t2.value_1
ORDER BY
	1;
 value_1 
---------
       1
       2
       3
(3 rows)

SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1, reference_table_test_second t2
WHERE
	t1.value_2 = t2.value_3::int
ORDER BY
	1;
 value_1 
---------
       1
       2
       3
(3 rows)

SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1, reference_table_test_second t2
WHERE
	t1.value_2 = date_part('day', t2.value_4)
ORDER BY
	1;
 value_1 
---------
       1
       2
       3
(3 rows)

-- ingest a common row to see more meaningful results with joins involving 3 tables
INSERT INTO reference_table_test_third VALUES (3, 3.0, '3', '2016-12-03');
SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1, reference_table_test_second t2, reference_table_test_third t3
WHERE
	t1.value_2 = date_part('day', t2.value_4) AND t3.value_2 = t1.value_2
ORDER BY
	1;
 value_1 
---------
       3
(1 row)

-- same query on different columns
SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1, reference_table_test_second t2, reference_table_test_third t3
WHERE
	t1.value_1 = date_part('day', t2.value_4) AND t3.value_2 = t1.value_1
ORDER BY
	1;
 value_1 
---------
       3
(1 row)

-- with the JOIN syntax
SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1 JOIN reference_table_test_second t2 USING (value_1)
							JOIN reference_table_test_third t3 USING (value_1)
ORDER BY
	1;
 value_1 
---------
       3
(1 row)

-- and left/right joins
SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1 LEFT JOIN reference_table_test_second t2 USING (value_1)
							LEFT JOIN reference_table_test_third t3 USING (value_1)
ORDER BY
	1;
 value_1 
---------
       1
       2
       3
       4
       5
(5 rows)

SELECT
	DISTINCT t1.value_1
FROM
	reference_table_test t1 RIGHT JOIN reference_table_test_second t2 USING (value_1)
							RIGHT JOIN reference_table_test_third t3 USING (value_1)
ORDER BY
	1;
 value_1 
---------
       3
        
(2 rows)

-- now, lets have some tests on UPSERTs and uniquness
CREATE TABLE reference_table_test_fourth (value_1 int, value_2 float PRIMARY KEY, value_3 text, value_4 timestamp);
SELECT create_reference_table('reference_table_test_fourth');
 create_reference_table 
------------------------
 
(1 row)

-- insert a row
INSERT INTO reference_table_test_fourth VALUES (1, 1.0, '1', '2016-12-01');
-- now get the unique key violation
INSERT INTO reference_table_test_fourth VALUES (1, 1.0, '1', '2016-12-01');
ERROR:  duplicate key value violates unique constraint "reference_table_test_fourth_pkey_1250003"
DETAIL:  Key (value_2)=(1) already exists.
CONTEXT:  while executing command on localhost:57637
-- now get null constraint violation due to primary key
INSERT INTO reference_table_test_fourth (value_1, value_3, value_4) VALUES (1, '1.0', '2016-12-01');
ERROR:  null value in column "value_2" violates not-null constraint
DETAIL:  Failing row contains (1, null, 1.0, 2016-12-01 00:00:00).
CONTEXT:  while executing command on localhost:57637
-- lets run some upserts
INSERT INTO reference_table_test_fourth VALUES (1, 1.0, '1', '2016-12-01') ON CONFLICT DO NOTHING RETURNING *;
 value_1 | value_2 | value_3 | value_4 
---------+---------+---------+---------
(0 rows)

INSERT INTO reference_table_test_fourth VALUES (1, 1.0, '10', '2016-12-01') ON CONFLICT (value_2) DO
	UPDATE SET value_3 = EXCLUDED.value_3, value_2 = EXCLUDED.value_2
	RETURNING *;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
       1 |       1 | 10      | Thu Dec 01 00:00:00 2016
(1 row)

-- update all columns
INSERT INTO reference_table_test_fourth VALUES (1, 1.0, '10', '2016-12-01') ON CONFLICT (value_2) DO
	UPDATE SET value_3 = EXCLUDED.value_3 || '+10', value_2 = EXCLUDED.value_2 + 10, value_1 = EXCLUDED.value_1 + 10, value_4 = '2016-12-10'
	RETURNING *;
 value_1 | value_2 | value_3 |         value_4          
---------+---------+---------+--------------------------
      11 |      11 | 10+10   | Sat Dec 10 00:00:00 2016
(1 row)

-- finally see that shard healths are OK
SELECT
	shardid, shardstate, nodename, nodeport
FROM
	pg_dist_shard_placement
WHERE
	shardid IN (SELECT shardid FROM pg_dist_shard WHERE logicalrelid = 'reference_table_test_fourth'::regclass);
 shardid | shardstate | nodename  | nodeport 
---------+------------+-----------+----------
 1250003 |          1 | localhost |    57637
 1250003 |          1 | localhost |    57638
(2 rows)

